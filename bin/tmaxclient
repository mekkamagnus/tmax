#!/usr/bin/env bun
/**
 * @file tmaxclient
 * @description Client CLI tool for connecting to tmax server
 * Implements JSON-RPC 2.0 protocol for communication with server
 */

import { Socket } from 'net';
import { userInfo } from 'os';
import { spawnSync } from 'child_process';

// JSON-RPC 2.0 interfaces
interface JSONRPCRequest {
  jsonrpc: '2.0';
  id: string | number;
  method: string;
  params?: any;
}

interface JSONRPCResponse {
  jsonrpc: '2.0';
  id: string | number;
  result?: any;
  error?: {
    code: number;
    message: string;
    data?: any;
  };
}

class TmaxClient {
  private socketPath: string;
  private connection: Socket | null = null;

  constructor(socketPath?: string) {
    this.socketPath = socketPath || this.getDefaultSocketPath();
  }

  /**
   * Get the default socket path
   */
  private getDefaultSocketPath(): string {
    const uid = process.env.SUDO_UID || userInfo().uid.toString();
    return `/tmp/tmax-${uid}/server`;
  }

  /**
   * Connect to the server
   */
  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.connection = new Socket();

      this.connection.connect(this.socketPath, () => {
        resolve();
      });

      this.connection.on('error', (err) => {
        reject(err);
      });
    });
  }

  /**
   * Send a request to the server
   */
  async sendRequest(method: string, params: any): Promise<any> {
    if (!this.connection) {
      throw new Error('Not connected to server');
    }

    const requestId = Date.now();
    const request: JSONRPCRequest = {
      jsonrpc: '2.0',
      id: requestId,
      method,
      params
    };

    return new Promise((resolve, reject) => {
      // Set up response handler
      const responseHandler = (data: Buffer) => {
        try {
          const responseStr = data.toString();
          const responses = this.parseMultipleResponses(responseStr);

          for (const response of responses) {
            if (response.id === requestId) {
              this.connection?.removeListener('data', responseHandler);

              if (response.error) {
                reject(new Error(`${response.error.code}: ${response.error.message}`));
              } else {
                resolve(response.result);
              }
              return;
            }
          }
        } catch (error) {
          this.connection?.removeListener('data', responseHandler);
          reject(error);
        }
      };

      this.connection.on('data', responseHandler);

      // Send request
      this.connection.write(JSON.stringify(request) + '\n');
    });
  }

  /**
   * Parse multiple JSON-RPC responses from a single data chunk
   */
  private parseMultipleResponses(data: string): JSONRPCResponse[] {
    const responses: JSONRPCResponse[] = [];
    let startPos = 0;
    let braceCount = 0;
    let inString = false;
    let escapeNext = false;

    for (let i = 0; i < data.length; i++) {
      const char = data[i];

      if (escapeNext) {
        escapeNext = false;
        continue;
      }

      if (char === '\\' && inString) {
        escapeNext = true;
        continue;
      }

      if (char === '"') {
        inString = !inString;
        continue;
      }

      if (!inString) {
        if (char === '{') {
          if (braceCount === 0) {
            startPos = i;
          }
          braceCount++;
        } else if (char === '}') {
          braceCount--;
          if (braceCount === 0) {
            try {
              const responseStr = data.substring(startPos, i + 1);
              const response = JSON.parse(responseStr.trim());
              if (response && typeof response === 'object') {
                responses.push(response);
              }
            } catch (e) {
              console.error('Error parsing JSON response:', e);
            }
          }
        }
      }
    }

    return responses;
  }

  /**
   * Open a file in the server
   */
  async openFile(filepath: string, options?: { wait?: boolean }): Promise<void> {
    const wait = options?.wait ?? true;

    try {
      await this.sendRequest('open', {
        filepath,
        wait
      });

      if (wait) {
        // For now, just return after sending the request
        // In a real implementation, we'd wait for the buffer to be closed
        return;
      }
    } catch (error) {
      console.error(`Error opening file ${filepath}:`, error);
      process.exit(1);
    }
  }

  /**
   * Evaluate T-Lisp code
   */
  async eval(code: string): Promise<any> {
    try {
      return await this.sendRequest('eval', { code });
    } catch (error) {
      console.error(`Error evaluating code:`, error);
      process.exit(1);
    }
  }

  /**
   * Execute a command
   */
  async executeCommand(command: string, params?: any): Promise<any> {
    try {
      return await this.sendRequest('command', { command, ...params });
    } catch (error) {
      console.error(`Error executing command ${command}:`, error);
      process.exit(1);
    }
  }

  /**
   * Query server state
   */
  async query(query: string, params?: any): Promise<any> {
    try {
      return await this.sendRequest('query', { query, ...params });
    } catch (error) {
      console.error(`Error querying server:`, error);
      process.exit(1);
    }
  }

  /**
   * Ping the server
   */
  async ping(): Promise<boolean> {
    try {
      const result = await this.sendRequest('ping', {});
      // Just output the status without extra info for clean exit code handling
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Close the connection
   */
  close(): void {
    if (this.connection) {
      this.connection.destroy();
      this.connection = null;
    }
  }
}

/**
 * Main function to handle command line arguments
 */
async function main(): Promise<void> {
  const args = process.argv.slice(2);

  // Show help if requested
  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
tmaxclient - Client for tmax server

Usage: tmaxclient [options] [filename]

Options:
  --eval CODE            Evaluate T-Lisp code
  --list-buffers         List all buffers
  --kill-buffer NAME     Kill specific buffer
  --insert TEXT          Insert text at cursor
  --insert-stdin         Insert from stdin
  --script FILE          Execute T-Lisp file
  --server-info          Get server info
  --ping                 Check if server running
  -n, --no-wait         Don't wait for buffer to close
  -c                     Open in new frame/buffer (not implemented yet)
  -nw                   No window mode (not implemented yet, for $EDITOR)
  -s, --socket PATH     Custom socket path
  -h, --help            Show this help message

Examples:
  tmaxclient file.txt           # Open file.txt
  tmaxclient --eval '(buffer-list)'  # Evaluate T-Lisp
  tmaxclient --list-buffers     # List all buffers
  tmaxclient --kill-buffer scratch.tlisp  # Kill specific buffer
  tmaxclient -n file.txt        # Open file without waiting
  tmaxclient -s /tmp/my-socket file.txt  # Use custom socket
  echo 'TODO' | tmaxclient --insert-stdin  # Insert from stdin
  tmaxclient --ping             # Check if server running
    `);
    process.exit(0);
  }

  // Parse arguments
  let socketPath: string | undefined;
  let noWait = args.includes('-n') || args.includes('--no-wait');
  let newFrame = args.includes('-c');  // Open in new frame/buffer
  let noWindow = args.includes('-nw'); // No window mode (for $EDITOR compatibility)
  let evalCode: string | undefined;
  let listBuffers = args.includes('--list-buffers');
  let killBuffer: string | undefined;
  let insertText: string | undefined;
  let scriptFile: string | undefined;
  let serverInfo = args.includes('--server-info');
  let ping = args.includes('--ping');
  let insertStdin = args.includes('--insert-stdin');

  // Parse socket path
  const socketIndex = args.indexOf('-s');
  if (socketIndex !== -1) {
    socketPath = args[socketIndex + 1];
  }

  const socketArgIndex = args.indexOf('--socket');
  if (socketArgIndex !== -1) {
    socketPath = args[socketArgIndex + 1];
  }

  // Parse eval code
  const evalIndex = args.indexOf('--eval');
  if (evalIndex !== -1) {
    evalCode = args[evalIndex + 1];
  }

  // Parse kill buffer
  const killIndex = args.indexOf('--kill-buffer');
  if (killIndex !== -1) {
    killBuffer = args[killIndex + 1];
  }

  // Parse insert text
  const insertIndex = args.indexOf('--insert');
  if (insertIndex !== -1) {
    insertText = args[insertIndex + 1];
  }

  // Parse script file
  const scriptIndex = args.indexOf('--script');
  if (scriptIndex !== -1) {
    scriptFile = args[scriptIndex + 1];
  }

  // Get non-option arguments (filenames)
  const filenames = args.filter(arg =>
    !arg.startsWith('-') &&
    arg !== evalCode &&
    arg !== killBuffer &&
    arg !== insertText &&
    arg !== scriptFile &&
    arg !== socketPath
  );

  // Special handling for ping - don't require server connection
  if (ping) {
    // Try to connect to test if server is running
    const client = new TmaxClient(socketPath);
    try {
      await client.connect();
      const isRunning = await client.ping();
      client.close();
      if (isRunning) {
        console.log(JSON.stringify({ status: 'running', server: 'tmax' }));
      }
      process.exit(isRunning ? 0 : 1);
    } catch (error) {
      // Server not running
      console.error('tmax server not running');
      process.exit(1);
    }
  }

  // Create client
  const client = new TmaxClient(socketPath);

  try {
    await client.connect();
  } catch (error) {
    console.error('Error connecting to tmax server:', error.message);
    console.error('Make sure the server is running with: tmax --daemon');
    process.exit(1);
  }

  // Handle different commands
  if (serverInfo) {
    const info = await client.query('full-state');
    console.log(JSON.stringify(info, null, 2));
  } else if (listBuffers) {
    const buffers = await client.executeCommand('list-buffers');
    // Format output similar to how a real editor might show buffer list
    if (Array.isArray(buffers)) {
      buffers.forEach(buffer => console.log(buffer));
    } else {
      console.log(buffers);
    }
  } else if (killBuffer) {
    const result = await client.executeCommand('kill-buffer', { bufferName: killBuffer });
    if (result.success) {
      console.log(`Buffer ${killBuffer} killed`);
      process.exit(0);
    } else {
      console.error(result.error);
      process.exit(1);
    }
  } else if (insertText) {
    // Use the insert method to add text to the buffer
    const result = await client.sendRequest('insert', { text: insertText });
    console.log(result);
  } else if (insertStdin) {
    // Read from stdin and insert
    const stdin = await readStdin();
    const result = await client.sendRequest('insert', { text: stdin });
    console.log(result);
  } else if (scriptFile) {
    // Read the script file and evaluate it
    const fs = require('fs');
    const scriptContent = fs.readFileSync(scriptFile, 'utf8');
    const result = await client.eval(scriptContent);
    console.log(result);
  } else if (evalCode) {
    const result = await client.eval(evalCode);
    if (result !== undefined) {
      console.log(typeof result === 'object' ? JSON.stringify(result) : result);
    }
  } else if (filenames.length > 0) {
    // Open files
    for (const filename of filenames) {
      await client.openFile(filename, { wait: !noWait });
    }
    // Exit with success code after opening files
    process.exit(0);
  } else {
    // No command specified, show help
    console.error('No command specified. Use --help for usage information.');
    process.exit(1);
  }

  client.close();
}

/**
 * Read from stdin
 */
async function readStdin(): Promise<string> {
  return new Promise((resolve) => {
    let data = '';
    process.stdin.setEncoding('utf8');

    process.stdin.on('readable', () => {
      let chunk;
      while ((chunk = process.stdin.read()) !== null) {
        data += chunk;
      }
    });

    process.stdin.on('end', () => {
      resolve(data);
    });
  });
}

// Run the main function
main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});